/**
* Copyright (c) 2017-present, Facebook, Inc.
* All rights reserved.

* This source code is licensed under the BSD-style license found in the
* LICENSE file in the root directory of this source tree.
*/

#include "engine/cmd.h"
#include "engine/game_env.h"
#include "engine/cmd_receiver.h"

// Derived class. Note that the definition is automatically generated by a python file.
#include "engine/cmd.gen.h"
#include "engine/cmd_specific.gen.h"
#include "cmd_specific.gen.h"

bool CmdGenerateMap::run(GameEnv *env, CmdReceiver*) {
   // std::cout<<"CmdGenerateMap"<<std::endl;
    return env->GenerateMap(_num_obstacles, _init_resource) ? true : false;
}

#define _CREATE(...) receiver->SendCmd(CmdIPtr(new CmdCreate(INVALID, __VA_ARGS__)))
#define _CHANGE_RES(...) receiver->SendCmd(CmdIPtr(new CmdChangePlayerResource(INVALID, __VA_ARGS__)))


bool CmdGameStartSpecific::run(GameEnv*, CmdReceiver* receiver) {
   // std::cout<<"CmdGameStartSpecific"<<std::endl;
    const PlayerId player_id = 0;
    const PlayerId enemy_id = 1;
    _CREATE(RESOURCE, PointF(2, 1), player_id);
    _CREATE(WORKER, PointF(4, 4), player_id);
    _CREATE(WORKER, PointF(5, 5), player_id);
    _CREATE(WORKER, PointF(6, 7), player_id);
    //_CREATE(RANGE_ATTACKER, PointF(15, 18), player_id);
    _CREATE(BASE, PointF(7, 2), player_id);
    //_CREATE(BARRACKS, PointF(8, 5), player_id);
    _CHANGE_RES(player_id, 100);

    _CREATE(BASE, PointF(18, 16), enemy_id);
    //_CREATE(WORKER, PointF(17, 15), enemy_id);
    //_CREATE(WORKER, PointF(18, 15), enemy_id);
    //_CREATE(WORKER, PointF(19, 16), enemy_id);
    _CREATE(RESOURCE, PointF(14, 18), enemy_id);
    //_CREATE(RANGE_ATTACKER, PointF(12, 11), enemy_id);
    _CHANGE_RES(enemy_id, 100);

    return true;
}

//-----------------Test--------------------
//创建雷达并设置朝向
bool CreateRadar(Tick _tick,GameEnv* env,PlayerId player_id,PointF radar_p,PointF towards){
   UnitId radar_id;
   if(! env->AddUnit(_tick, RANGE_ATTACKER, radar_p, player_id,radar_id)){
        std::cout<<"create radar failed at "<<radar_p<<std::endl;
        return false;
    }
   Unit* radar = env->GetUnit(radar_id);
   if(radar == nullptr) return false; //雷达创建失败
   //设置雷达朝向
   radar->GetProperty().towards.x = towards.x;
   radar->GetProperty().towards.y = towards.y;
   //std::cout<<"Create Radar at "<<radar->GetPointF()<<" towards "<<radar->GetProperty().towards<<std::endl;
   return true;

}
bool CmdGenerateUnit::run(GameEnv *env, CmdReceiver *receiver) {
    //std::cout<<"CmdGenerateTDUnit"<<std::endl;
    const PlayerId player_id = 0;
    const PlayerId enemy_id = 1;
    // 保护目标
    _CREATE(BASE, PointF(35, 35), player_id);
    /**
     *   if (! build_p.IsInvalid()) {
                   // 创造导弹 
                   UnitId rocket_id;
                   
                   if (! env_temp.AddUnit(_tick, BARRACKS, build_p, u->GetPlayerId(),rocket_id)) {
                        std::cout<<"emit rocket failed"<<std::endl;
                        return false;
                    }
                    //载弹量 -1
                    --env_temp.GetUnit(_id)->GetProperty().round;
                    // 发射导弹(让导弹去攻击目标)
                    receiver->SendCmd(CmdBPtr(new CmdAttack(rocket_id, _target)));
                    _done = true;
                }
     * **/
    // 雷达
    PointF radar_1_p = PointF(36,34.8); //雷达1位置
    PointF radar_2_p = PointF(34,34.8); //雷达2位置
    if(!CreateRadar(_tick,env,player_id,radar_1_p,PointF(1,-1.732))) return false;
   
    if(!CreateRadar(_tick,env,player_id,radar_2_p,PointF(-1,-1.732))) return false;
    
    //if(!CreateRadar(_tick,env,player_id,radar_1_p,PointF(-1,1.732))) return false;
   //if(!CreateRadar(_tick,env,player_id,radar_2_p,PointF(1,1.732))) return false;
    //_CREATE(RANGE_ATTACKER,PointF(36,34.8),player_id);
    //_CREATE(RANGE_ATTACKER,PointF(34,34.8),player_id);
    
    
    // 炮台
    // B1
    _CREATE(MELEE_ATTACKER,PointF(29.0122,34.4522),player_id);
    _CREATE(MELEE_ATTACKER,PointF(29.30155,33.0899),player_id);
    _CREATE(MELEE_ATTACKER,PointF(29.9549,31.86105),player_id);
    _CREATE(MELEE_ATTACKER,PointF(30.9217,30.85995),player_id);
    _CREATE(MELEE_ATTACKER,PointF(32.12695,30.1641),player_id);
    _CREATE(MELEE_ATTACKER,PointF(33.47735,29.8274),player_id);
    _CREATE(MELEE_ATTACKER,PointF(34.86825,29.87595),player_id);
    _CREATE(MELEE_ATTACKER,PointF(36.19185,30.30605),player_id);

    // B2
    _CREATE(MELEE_ATTACKER,PointF(40.9878,34.4522),player_id);
    _CREATE(MELEE_ATTACKER,PointF(40.69845,33.0899),player_id);
    _CREATE(MELEE_ATTACKER,PointF(40.0451,31.86105),player_id);
    _CREATE(MELEE_ATTACKER,PointF(39.0783,30.85995),player_id);
    _CREATE(MELEE_ATTACKER,PointF(37.87305,30.1641),player_id);
    _CREATE(MELEE_ATTACKER,PointF(36.52265,29.8274),player_id);
    _CREATE(MELEE_ATTACKER,PointF(35.13175,29.87595),player_id);
    _CREATE(MELEE_ATTACKER,PointF(33.80815,30.30605),player_id);
    

    // _CREATE(MELEE_ATTACKER,PointF(40,40),player_id);
    // _CREATE(MELEE_ATTACKER,PointF(40,30),player_id);
    // _CREATE(MELEE_ATTACKER,PointF(30,40),player_id);
    // _CREATE(MELEE_ATTACKER,PointF(30,30),player_id);

    // //
    //  //_CREATE(WORKER,PointF(50,50),player_id);
    //  //_CREATE(BARRACKS,PointF(55,55),player_id);
     _CHANGE_RES(player_id, 100);



   

    // enemy
    //_CREATE(BASE,PointF(1, 1),enemy_id);
    _CREATE(WORKER,PointF(1,1),enemy_id);
    _CREATE(WORKER,PointF(34,1),enemy_id);
    _CREATE(WORKER,PointF(36,1),enemy_id);
    _CREATE(WORKER,PointF(68,1),enemy_id);
    // _CREATE(WORKER,PointF(35,26),enemy_id);
    // _CREATE(BARRACKS,PointF(35,27),enemy_id);

    //_CREATE(BASE,PointF(35,10),enemy_id);
    //_CREATE(MELEE_ATTACKER,PointF(30,10),enemy_id);

    // _CHANGE_RES(enemy_id, 200000000);

    
    //_CREATE(WORKER,PointF(50,50),enemy_id);
    // 敌方飞机
    // _CREATE(WORKER,PointF(34,20),enemy_id);
    // _CREATE(WORKER,PointF(20,36),enemy_id);
    // _CREATE(WORKER,PointF(24,35),enemy_id);
    
    return true;

}

//-----------------Test--------------------
// bool CmdGenerateUnit::r  un(GameEnv *env, CmdReceiver *receiver) {
//    // std::cout<<"CmdGenerateUnit"<<std::endl;
//     auto f = env->GetRandomFunc();
//     int lr_seed = f(2);
//     int ud_seed = f(2);
//     bool shuffle_lr = (lr_seed == 0);
//     bool shuffle_ud = (ud_seed == 0);
//     auto shuffle_loc = [&] (PointF p, bool b1, bool b2) -> PointF {
//         int x = b1 ? 19 - p.x : p.x;
//         int y = b2 ? 19 - p.y : p.y;
//         return PointF(x, y);
//     };

//     receiver->GetGameStats().PickBase(lr_seed * 2 + ud_seed);
//     for (const auto &info : env->GetMap().GetPlayerMapInfo()) {
//         PlayerId id = info.player_id;
//         _CREATE(BASE, shuffle_loc(PointF(info.base_coord), shuffle_lr, shuffle_ud), id);
//         _CREATE(RESOURCE, shuffle_loc(PointF(info.resource_coord), shuffle_lr, shuffle_ud), id);
//         _CHANGE_RES(id, info.initial_resource);
//         //base_locs[id] = PointF(info.base_coord);
//     }
//     // for (size_t i = 0; i < base_locs.size(); ++i) {
//     //    std::cout << "[" << i << "] Baseloc: " << base_locs[i].x << ", " << base_locs[i].y << std::endl;
//     //}
//     auto gen_loc = [&] (int player_id) -> PointF {
//         // Note that we could not write
//         //    PointF( f(8) + ...,  f(8) + ...)
//         // since the result will depend on which f is evaluated first, and will yield different results on
//         // different platform/compiler (e.g., clang and gcc yields different results).
//         // The following implementation is uniquely determined.
//         int x = f(6) + player_id * 10 + 2;
//         int y = f(6) + player_id * 10 + 2;
//         return PointF(x, y);
//     };
//     for (PlayerId player_id = 0; player_id < 2; player_id++) {
//         PlayerId id = player_id;
//         // Generate workers (up to three).
//         for (int i = 0; i < 3; i++) {
//             if (f(10) >= 5) {
//                 _CREATE(WORKER, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//             }
//         }
//         if (f(10) >= 8)
//             _CREATE(BARRACKS, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//         if (f(10) >= 5)
//             _CREATE(MELEE_ATTACKER, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//         if (f(10) >= 5)
//             _CREATE(RANGE_ATTACKER, shuffle_loc(gen_loc(player_id), shuffle_lr, shuffle_ud), id);
//     }
//     return true;
// }

#undef _CHANGE_RES
#undef _CREATE
